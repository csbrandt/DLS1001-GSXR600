<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>sd-reader: FAT access</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>FAT access<br/>
<small>
[<a class="el" href="group__fat.html">FAT support</a>]</small>
</h1>
<p>Basic functions for handling a FAT filesystem.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct fat_fs_struct *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fat__fs.html#ga5d726bac328b49abc2e6fb022d97092a">fat_open</a> (struct <a class="el" href="structpartition__struct.html">partition_struct</a> *partition)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opens a FAT filesystem.  <a href="#ga5d726bac328b49abc2e6fb022d97092a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fat__fs.html#ga057612824886e115b88bf5affcf76829">fat_close</a> (struct fat_fs_struct *fs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes a FAT filesystem.  <a href="#ga057612824886e115b88bf5affcf76829"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cluster_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fat__fs.html#ga6330f6256b8f91fea0a1063aed58543d">fat_append_clusters</a> (struct fat_fs_struct *fs, cluster_t cluster_num, cluster_t count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends a new cluster chain to an existing one.  <a href="#ga6330f6256b8f91fea0a1063aed58543d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fat__fs.html#ga5fedd7fe78ee8929853d192bdda74b6a">fat_free_clusters</a> (struct fat_fs_struct *fs, cluster_t cluster_num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a cluster chain, or a part thereof.  <a href="#ga5fedd7fe78ee8929853d192bdda74b6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fat__fs.html#gad41cf0012613a0f2ed8475877a1c6833">fat_terminate_clusters</a> (struct fat_fs_struct *fs, cluster_t cluster_num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a part of a cluster chain and correctly terminates the rest.  <a href="#gad41cf0012613a0f2ed8475877a1c6833"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fat__fs.html#ga26f67009224e37933a802aa4471828c8">fat_clear_cluster</a> (const struct fat_fs_struct *fs, cluster_t cluster_num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears a single cluster.  <a href="#ga26f67009224e37933a802aa4471828c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga536c49c22c88b948f556d0d26e153312"></a><!-- doxytag: member="fat_fs::fat_clear_cluster_callback" ref="ga536c49c22c88b948f556d0d26e153312" args="(uint8_t *buffer, offset_t offset, void *p)" -->
uintptr_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fat__fs.html#ga536c49c22c88b948f556d0d26e153312">fat_clear_cluster_callback</a> (uint8_t *buffer, offset_t offset, void *p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function for clearing a cluster. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fat__fs.html#ga673a611251d6585329039900eaff2b12">fat_calc_83_checksum</a> (const uint8_t *file_name_83)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the checksum for 8.3 names used within the corresponding lfn directory entries.  <a href="#ga673a611251d6585329039900eaff2b12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">offset_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fat__fs.html#ga5985869d0bc8cd439e51cd1a6db0f9cf">fat_find_offset_for_dir_entry</a> (struct fat_fs_struct *fs, const struct fat_dir_struct *parent, const struct <a class="el" href="structfat__dir__entry__struct.html">fat_dir_entry_struct</a> *dir_entry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for space where to store a directory entry.  <a href="#ga5985869d0bc8cd439e51cd1a6db0f9cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fat__fs.html#ga6f1d609b45c2907bf97b5f6002978e9d">fat_write_dir_entry</a> (const struct fat_fs_struct *fs, struct <a class="el" href="structfat__dir__entry__struct.html">fat_dir_entry_struct</a> *dir_entry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a directory entry to disk.  <a href="#ga6f1d609b45c2907bf97b5f6002978e9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">offset_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fat__fs.html#gaab7768ca45847d5c4033a91984d65f1a">fat_get_fs_size</a> (const struct fat_fs_struct *fs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the amount of total storage capacity of the filesystem in bytes.  <a href="#gaab7768ca45847d5c4033a91984d65f1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">offset_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fat__fs.html#gacc43179721b97d82fefafaf5625350bb">fat_get_fs_free</a> (const struct fat_fs_struct *fs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the amount of free storage capacity on the filesystem in bytes.  <a href="#gacc43179721b97d82fefafaf5625350bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafee6ea130655af67845e1cebe9a96bfc"></a><!-- doxytag: member="fat_fs::fat_get_fs_free_32_callback" ref="gafee6ea130655af67845e1cebe9a96bfc" args="(uint8_t *buffer, offset_t offset, void *p)" -->
uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fat__fs.html#gafee6ea130655af67845e1cebe9a96bfc">fat_get_fs_free_32_callback</a> (uint8_t *buffer, offset_t offset, void *p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function used for counting free clusters in a FAT32. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Basic functions for handling a FAT filesystem. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6330f6256b8f91fea0a1063aed58543d"></a><!-- doxytag: member="fat.c::fat_append_clusters" ref="ga6330f6256b8f91fea0a1063aed58543d" args="(struct fat_fs_struct *fs, cluster_t cluster_num, cluster_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cluster_t fat_append_clusters </td>
          <td>(</td>
          <td class="paramtype">struct fat_fs_struct *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cluster_t&nbsp;</td>
          <td class="paramname"> <em>cluster_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cluster_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Appends a new cluster chain to an existing one. </p>
<p>Set cluster_num to zero to create a completely new one.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fs</em>&nbsp;</td><td>The file system on which to operate. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cluster_num</em>&nbsp;</td><td>The cluster to which to append the new chain. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The number of clusters to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, the number of the first new cluster on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga673a611251d6585329039900eaff2b12"></a><!-- doxytag: member="fat.c::fat_calc_83_checksum" ref="ga673a611251d6585329039900eaff2b12" args="(const uint8_t *file_name_83)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t fat_calc_83_checksum </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>file_name_83</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the checksum for 8.3 names used within the corresponding lfn directory entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>file_name_83</em>&nbsp;</td><td>The 11-byte file name buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The checksum of the given file name. </dd></dl>

</div>
</div>
<a class="anchor" id="ga26f67009224e37933a802aa4471828c8"></a><!-- doxytag: member="fat.c::fat_clear_cluster" ref="ga26f67009224e37933a802aa4471828c8" args="(const struct fat_fs_struct *fs, cluster_t cluster_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t fat_clear_cluster </td>
          <td>(</td>
          <td class="paramtype">const struct fat_fs_struct *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cluster_t&nbsp;</td>
          <td class="paramname"> <em>cluster_num</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears a single cluster. </p>
<p>The complete cluster is filled with zeros.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fs</em>&nbsp;</td><td>The filesystem on which to operate. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cluster_num</em>&nbsp;</td><td>The cluster to clear. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, 1 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga057612824886e115b88bf5affcf76829"></a><!-- doxytag: member="fat.c::fat_close" ref="ga057612824886e115b88bf5affcf76829" args="(struct fat_fs_struct *fs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fat_close </td>
          <td>(</td>
          <td class="paramtype">struct fat_fs_struct *&nbsp;</td>
          <td class="paramname"> <em>fs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes a FAT filesystem. </p>
<p>When this function returns, the given filesystem descriptor will be invalid.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fs</em>&nbsp;</td><td>The filesystem to close. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fat.html#ga5d726bac328b49abc2e6fb022d97092a" title="Opens a FAT filesystem.">fat_open</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5985869d0bc8cd439e51cd1a6db0f9cf"></a><!-- doxytag: member="fat.c::fat_find_offset_for_dir_entry" ref="ga5985869d0bc8cd439e51cd1a6db0f9cf" args="(struct fat_fs_struct *fs, const struct fat_dir_struct *parent, const struct fat_dir_entry_struct *dir_entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">offset_t fat_find_offset_for_dir_entry </td>
          <td>(</td>
          <td class="paramtype">struct fat_fs_struct *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct fat_dir_struct *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structfat__dir__entry__struct.html">fat_dir_entry_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>dir_entry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches for space where to store a directory entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fs</em>&nbsp;</td><td>The filesystem on which to operate. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parent</em>&nbsp;</td><td>The directory in which to search. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dir_entry</em>&nbsp;</td><td>The directory entry for which to search space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, a device offset on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5fedd7fe78ee8929853d192bdda74b6a"></a><!-- doxytag: member="fat.c::fat_free_clusters" ref="ga5fedd7fe78ee8929853d192bdda74b6a" args="(struct fat_fs_struct *fs, cluster_t cluster_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t fat_free_clusters </td>
          <td>(</td>
          <td class="paramtype">struct fat_fs_struct *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cluster_t&nbsp;</td>
          <td class="paramname"> <em>cluster_num</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees a cluster chain, or a part thereof. </p>
<p>Marks the specified cluster and all clusters which are sequentially referenced by it as free. They may then be used again for future file allocations.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If this function is used for freeing just a part of a cluster chain, the new end of the chain is not correctly terminated within the FAT. Use <a class="el" href="group__fat__fs.html#gad41cf0012613a0f2ed8475877a1c6833" title="Frees a part of a cluster chain and correctly terminates the rest.">fat_terminate_clusters()</a> instead.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fs</em>&nbsp;</td><td>The filesystem on which to operate. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cluster_num</em>&nbsp;</td><td>The starting cluster of the chain which to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, 1 on success. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fat__fs.html#gad41cf0012613a0f2ed8475877a1c6833" title="Frees a part of a cluster chain and correctly terminates the rest.">fat_terminate_clusters</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacc43179721b97d82fefafaf5625350bb"></a><!-- doxytag: member="fat.c::fat_get_fs_free" ref="gacc43179721b97d82fefafaf5625350bb" args="(const struct fat_fs_struct *fs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">offset_t fat_get_fs_free </td>
          <td>(</td>
          <td class="paramtype">const struct fat_fs_struct *&nbsp;</td>
          <td class="paramname"> <em>fs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the amount of free storage capacity on the filesystem in bytes. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>As the FAT filesystem is cluster based, this function does not return continuous values but multiples of the cluster size.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fs</em>&nbsp;</td><td>The filesystem on which to operate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, the free filesystem space in bytes otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gaab7768ca45847d5c4033a91984d65f1a"></a><!-- doxytag: member="fat.c::fat_get_fs_size" ref="gaab7768ca45847d5c4033a91984d65f1a" args="(const struct fat_fs_struct *fs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">offset_t fat_get_fs_size </td>
          <td>(</td>
          <td class="paramtype">const struct fat_fs_struct *&nbsp;</td>
          <td class="paramname"> <em>fs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the amount of total storage capacity of the filesystem in bytes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fs</em>&nbsp;</td><td>The filesystem on which to operate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, the filesystem size in bytes otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d726bac328b49abc2e6fb022d97092a"></a><!-- doxytag: member="fat.c::fat_open" ref="ga5d726bac328b49abc2e6fb022d97092a" args="(struct partition_struct *partition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fat_fs_struct* fat_open </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpartition__struct.html">partition_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>partition</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens a FAT filesystem. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>partition</em>&nbsp;</td><td>Discriptor of partition on which the filesystem resides. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, a FAT filesystem descriptor on success. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fat.html#ga057612824886e115b88bf5affcf76829" title="Closes a FAT filesystem.">fat_close</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad41cf0012613a0f2ed8475877a1c6833"></a><!-- doxytag: member="fat.c::fat_terminate_clusters" ref="gad41cf0012613a0f2ed8475877a1c6833" args="(struct fat_fs_struct *fs, cluster_t cluster_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t fat_terminate_clusters </td>
          <td>(</td>
          <td class="paramtype">struct fat_fs_struct *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cluster_t&nbsp;</td>
          <td class="paramname"> <em>cluster_num</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees a part of a cluster chain and correctly terminates the rest. </p>
<p>Marks the specified cluster as the new end of a cluster chain and frees all following clusters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fs</em>&nbsp;</td><td>The filesystem on which to operate. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cluster_num</em>&nbsp;</td><td>The new end of the cluster chain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, 1 on success. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fat__fs.html#ga5fedd7fe78ee8929853d192bdda74b6a" title="Frees a cluster chain, or a part thereof.">fat_free_clusters</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6f1d609b45c2907bf97b5f6002978e9d"></a><!-- doxytag: member="fat.c::fat_write_dir_entry" ref="ga6f1d609b45c2907bf97b5f6002978e9d" args="(const struct fat_fs_struct *fs, struct fat_dir_entry_struct *dir_entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t fat_write_dir_entry </td>
          <td>(</td>
          <td class="paramtype">const struct fat_fs_struct *&nbsp;</td>
          <td class="paramname"> <em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfat__dir__entry__struct.html">fat_dir_entry_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>dir_entry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a directory entry to disk. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The file name is not checked for invalid characters.</dd>
<dd>
The generation of the short 8.3 file name is quite simple. The first eight characters are used for the filename. The extension, if any, is made up of the first three characters following the last dot within the long filename. If the filename (without the extension) is longer than eight characters, the lower byte of the cluster number replaces the last two characters to avoid name clashes. In any other case, it is your responsibility to avoid name clashes.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fs</em>&nbsp;</td><td>The filesystem on which to operate. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dir_entry</em>&nbsp;</td><td>The directory entry to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, 1 on success. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Jan 10 12:15:06 2010 for sd-reader by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
